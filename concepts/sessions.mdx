---
title: "Sessions"
description: "Understanding tmux sessions - lifecycle, management, and commands"
---

## What is a Session?

A tmux **session** is a single collection of pseudo terminals under the management of tmux. Each session has one or more windows linked to it and maintains its own environment, options, and state.

<Info>
Sessions are persistent and will survive accidental disconnection (such as SSH connection timeout) or intentional detaching. You can reattach to them later using `tmux attach`.
</Info>

## Session Architecture

From the source code (session.c:109-158), sessions are implemented as structures with:

- **Unique ID**: Each session has a numeric ID prefixed with `$` (e.g., `$0`, `$1`)
- **Name**: A user-friendly name for identification
- **Windows Tree**: An RB tree (`RB_INIT(&s->windows)`) containing all windows
- **Current Window**: Pointer to the active window (`s->curw`)
- **Window Stack**: A stack of last-used windows (`TAILQ_INIT(&s->lastw)`)
- **Reference Count**: Tracks how many clients are attached
- **Activity Tracking**: Creation time and last activity timestamps
- **Working Directory**: Default directory for new windows

```c
// From session.c:111-127
struct session *
session_create(const char *prefix, const char *name, const char *cwd,
    struct environ *env, struct options *oo, struct termios *tio)
{
    struct session *s;
    s = xcalloc(1, sizeof *s);
    s->references = 1;
    s->cwd = xstrdup(cwd);
    TAILQ_INIT(&s->lastw);
    RB_INIT(&s->windows);
    s->environ = env;
    s->options = oo;
    // ...
}
```

## Session Lifecycle

### Creating Sessions

Sessions are created with `session_create()` and assigned:
- A unique session ID
- A name (auto-generated if not specified)
- Initial environment and options
- Creation and activity timestamps

<Tabs>
  <Tab title="Command">
    ```bash
    # Create a new session
    tmux new-session -s mysession
    
    # Create with specific name and command
    tmux new -s dev -n editor vim
    
    # Create detached session
    tmux new -d -s background
    ```
  </Tab>
  <Tab title="Source Reference">
    From session.c:109-158, `session_create()` function handles:
    - Memory allocation
    - ID assignment (`s->id = next_session_id++`)
    - Name generation or validation
    - Initialization of window structures
    - Environment setup
  </Tab>
</Tabs>

### Finding Sessions

The source provides multiple ways to locate sessions (session.c:70-107):

```c
// Find by name
struct session *session_find(const char *name);

// Find by ID string (e.g., "$0")
struct session *session_find_by_id_str(const char *s);

// Find by numeric ID
struct session *session_find_by_id(u_int id);
```

<Note>
Session names cannot contain `:` or `.` characters - they are replaced with `_` during name sanitization (session.c:232-248).
</Note>

### Attaching and Detaching

Sessions use reference counting to track attached clients:

```c
// session.c:160-177
void session_add_ref(struct session *s, const char *from) {
    s->references++;
}

void session_remove_ref(struct session *s, const char *from) {
    s->references--;
    if (s->references == 0)
        event_once(-1, EV_TIMEOUT, session_free, s, NULL);
}
```

<Tip>
When you detach from a session, it continues running in the background. The session is only destroyed when all references are removed.
</Tip>

### Session Destruction

From session.c:196-230, `session_destroy()` performs cleanup:

1. Removes session from global sessions tree
2. Sends `session-closed` notification
3. Removes from any session group
4. Destroys all window links
5. Cleans up last-window stack
6. Decrements reference count

```c
void session_destroy(struct session *s, int notify, const char *from) {
    RB_REMOVE(sessions, &sessions, s);
    if (notify)
        notify_session("session-closed", s);
    // Clean up windows, groups, etc.
    session_remove_ref(s, __func__);
}
```

## Window Management

Sessions manage windows through winlinks (session.c:340-377):

### Attaching Windows

```c
struct winlink *
session_attach(struct session *s, struct window *w, int idx, char **cause)
```

- Links a window at a specific index
- Notifies with `window-linked` event
- Synchronizes with session group if applicable

### Detaching Windows

```c
int session_detach(struct session *s, struct winlink *wl)
```

- Adjusts current window if necessary
- Clears alert flags
- Sends `window-unlinked` notification
- Returns 1 if session is now empty

## Navigating Windows

The source provides several navigation functions:

<Accordion title="Window Navigation Functions">

**Next Window** (session.c:417-435)
```c
int session_next(struct session *s, int alert)
```
Moves to the next window, optionally skipping to next alert.

**Previous Window** (session.c:448-466)
```c
int session_previous(struct session *s, int alert)
```
Moves to the previous window.

**Select by Index** (session.c:468-476)
```c
int session_select(struct session *s, int idx)
```
Jumps directly to a window by index.

**Last Window** (session.c:478-491)
```c
int session_last(struct session *s)
```
Switches to the previously active window.

</Accordion>

## Session Groups

Sessions can be grouped together to share windows (session.c:519-645):

<Info>
Sessions in the same group share windows - new windows are linked to all sessions in the group, and closing a window removes it from all sessions.
</Info>

### Key Functions

```c
// Find group containing a session
struct session_group *session_group_contains(struct session *target);

// Create new group
struct session_group *session_group_new(const char *name);

// Add session to group
void session_group_add(struct session_group *sg, struct session *s);
```

### Synchronization

Groups synchronize windows bidirectionally:
- `session_group_synchronize_to()` - sync session to group
- `session_group_synchronize_from()` - sync group from session

From session.c:647-708, synchronization:
1. Destroys all winlinks in target session
2. Recreates them from the source
3. Updates current window pointer
4. Rebuilds last-window stack
5. Preserves alert flags

## Activity Tracking

Sessions track activity for locking and monitoring (session.c:266-292):

```c
void session_update_activity(struct session *s, struct timeval *from)
```

- Updates `activity_time` timestamp
- Resets lock timer based on `lock-after-time` option
- Logs activity for debugging

<Tip>
Use `#{session_activity}` and `#{session_created}` format variables to display session timing information in status lines.
</Tip>

## Common Session Commands

| Command | Description | Source Reference |
|---------|-------------|------------------|
| `new-session` | Create new session | tmux.1:1268 |
| `attach-session` | Attach to existing session | tmux.1:1040 |
| `detach-client` | Detach from session | tmux.1:1138 |
| `kill-session` | Destroy session | tmux.1:1173 |
| `list-sessions` | Show all sessions | tmux.1:1228 |
| `rename-session` | Change session name | tmux.1:1534 |
| `switch-client` | Switch to different session | tmux.1:1647 |

## Session Identification

From tmux.1:753-785, sessions can be identified by:

1. **Session ID**: `$0`, `$1`, etc.
2. **Exact name**: Full session name
3. **Name prefix**: Start of session name (e.g., `myse` matches `mysession`)
4. **Glob pattern**: Wildcard matching against name

<Note>
Prefix session name with `=` for exact matching only (e.g., `=mysess` won't match `mysession`).
</Note>

## Best Practices

<Accordion title="Session Management Tips">

**Naming Conventions**
- Use descriptive names for easy identification
- Avoid special characters (`:` and `.` are replaced)
- Use consistent naming schemes (e.g., `work-project`, `dev-backend`)

**Session Groups**
- Group related sessions to share window layouts
- Remember that closing a window affects all sessions in the group
- Current window and options remain independent per session

**Resource Management**
- Sessions persist until explicitly killed
- Detached sessions continue consuming resources
- Use `kill-session -a` to kill all sessions except the current one

**Activity Monitoring**
- Set `lock-after-time` for automatic session locking
- Monitor `session_activity` for idle detection
- Use session groups for synchronized work environments

</Accordion>

## See Also

- [Windows](/concepts/windows) - Understanding window management
- [Panes](/concepts/panes) - Working with panes
- [Client-Server Architecture](/concepts/client-server) - How sessions fit in the architecture